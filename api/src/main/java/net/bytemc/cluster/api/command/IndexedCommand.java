package net.bytemc.cluster.api.command;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import net.bytemc.cluster.api.command.autocompletion.DefaultTabCompleter;
import net.bytemc.cluster.api.command.autocompletion.SubCommandTabCompleter;
import net.bytemc.cluster.api.command.autocompletion.TabCompleter;
import net.bytemc.cluster.api.command.commandsender.CommandSender;
import org.jetbrains.annotations.NotNull;

@AllArgsConstructor
@Getter
public final class IndexedCommand {

    private final String name;
    private final String[] aliases;
    private final String permission;
    @Setter
    private IndexedMethod defaultExecution;
    private TabCompleter tabCompleter;
    private final Map<String, IndexedMethod> subCommandMap = new HashMap<>();

    /**
     * Searches for a subcommand that might exist. If there is no subcommand, the given "default"
     * method is used or the autogenerated method is used.
     *
     * @param args the arguments given by the command sender
     */
    public void execute(
        @NotNull CommandSender commandSender,
        @NotNull List<String> args
    ) {
        if (!commandSender.hasPermission(permission)) {
            commandSender.sendNonePermission();
            return;
        }

        if (args.isEmpty()) {
            if (defaultExecution != null) {
                defaultExecution.invoke(commandSender, List.of());
            }
            return;
        }

        if (this.subCommandMap.isEmpty()) {
            if (this.defaultExecution != null) {
                this.defaultExecution.invoke(commandSender, args);
            }
            return;
        }

        final String subCommandName = args.remove(0);

        this.getOptionalMethod(subCommandName)
            .ifPresentOrElse(indexedMethod -> indexedMethod.invoke(commandSender, args),
                () -> {
                    if (defaultExecution != null) {
                        defaultExecution.invoke(commandSender, List.of());
                    }
                });
    }

    public List<String> complete(
        @NotNull CommandSender commandSender,
        @NotNull List<String> args,
        boolean jLineSupport
    ) {
        if (!commandSender.hasPermission(permission)) {
            commandSender.sendNonePermission();
            return List.of();
        }

        if (this.tabCompleter instanceof DefaultTabCompleter) {
            this.tabCompleter = new SubCommandTabCompleter(this);
        }

        if ((jLineSupport ? args.size() == 1 : args.isEmpty()) && !this.subCommandMap.isEmpty()) {
            return this.tabCompleter.complete(commandSender, args);
        }

        final String subCommandName = args.remove(0);

        Optional<IndexedMethod> optionalMethod = this.getOptionalMethod(subCommandName);
        if (optionalMethod.isPresent()) {
            return optionalMethod.get().getTabCompleter().complete(commandSender, args);
        }
        return List.of();
    }

    /**
     * Searches for subcommands
     *
     * @param name of the subcommand
     * @return an optional subcommand method
     */
    private Optional<IndexedMethod> getOptionalMethod(String name) {
        return Optional.ofNullable(subCommandMap.get(name));
    }
}
